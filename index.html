<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Snake Game with Store & Color Selector</title>
  <style>
    body {
      margin: 0;
      background: #222;
    }
    canvas {
      display: block;
      margin: 0 auto;
      box-shadow: 0 0 10px #000;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="600" height="700"></canvas>
  <script>
    // Get canvas and context
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    /* ======================
       Global Constants & Variables
       ====================== */
    const WIDTH = 600;
    const HEIGHT = 700;
    const GRID_SIZE = 20;
    const ROWS = Math.floor((HEIGHT - 100) / GRID_SIZE);
    const COLS = Math.floor(WIDTH / GRID_SIZE);

    // Colors
    const RED = "#ff0000";
    const BLACK = "#000000";
    const GRAY = "#969696";
    const GOLD = "#ffd700";
    const SCOREBOARD_BG = "#e6e6e6";

    // Global snake color (default green)
    let snake_color = "#00ff00";

    // Game state: "menu", "store", "playing", "game_over"
    let gameState = "menu";
    let gameLoopTimeout;

    // Game variables (reset in resetGame)
    let snake = null;
    let food = null;
    let score = 0;
    let level = 1;
    let speed = 150; // in ms
    let appleCount = 0;
    let bonusActive = false;
    let obstacles = [{ x: 10, y: 8 }, { x: 15, y: 12 }];

    // Clickable rectangles for menu and store
    let menuPlayButtonRect, menuStoreIconRect;
    let storeBackButtonRect, storeOptionRects;

    // Full list of color options (from the original Python code)
    const colorOptions = [
      { name: "Red", color: "#ff0000" },
      { name: "Blue", color: "#0000ff" },
      { name: "Green", color: "#00ff00" },
      { name: "Orange", color: "#ffa500" },
      { name: "White", color: "#ffffff" },
      { name: "Black", color: "#000000" },
      { name: "Yellow", color: "#ffff00" },
      { name: "Purple", color: "#800080" },
      { name: "Silver", color: "#c0c0c0" },
      { name: "Brown", color: "#a52a2a" },
      { name: "Gray", color: "#808080" },
      { name: "Pink", color: "#ffc0cb" },
      { name: "Olive", color: "#808000" },
      { name: "Maroon", color: "#800000" },
      { name: "Violet", color: "#ee82ee" },
      { name: "Charcoal", color: "#36454f" },
      { name: "Magenta", color: "#ff00ff" },
      { name: "Bronze", color: "#cd7f32" },
      { name: "Cream", color: "#fffdd0" },
      { name: "Gold", color: "#ffd700" },
      { name: "Tan", color: "#d2b48c" },
      { name: "Teal", color: "#008080" },
      { name: "Mustard", color: "#ffdb58" },
      { name: "Navy Blue", color: "#000080" },
      { name: "Coral", color: "#ff7f50" },
      { name: "Burgundy", color: "#800020" },
      { name: "Lavender", color: "#e6e6fa" },
      { name: "Mauve", color: "#e0b0ff" },
      { name: "Cyan", color: "#e0f7fa" },
      { name: "Peach", color: "#ffe5b4" },
      { name: "Rust", color: "#b7410e" },
      { name: "Indigo", color: "#4b0082" },
      { name: "Ruby", color: "#e0115f" },
      { name: "Lime Green", color: "#32cd32" },
      { name: "Salmon", color: "#fa8072" },
      { name: "Azure", color: "#007fff" },
      { name: "Beige", color: "#f5f5dc" },
      { name: "Copper Rose", color: "#996666" },
      { name: "Turquoise", color: "#40e0d0" },
      { name: "Aqua", color: "#00ffff" },
      { name: "Mint", color: "#3eb489" },
      { name: "Sky Blue", color: "#87ceeb" },
      { name: "Crimson", color: "#dc143c" },
      { name: "Saffron", color: "#f4c430" },
      { name: "Lemon Yellow", color: "#fff44f" },
      { name: "Grapevine", color: "#43254f" },
      { name: "Fuschia", color: "#ff00ff" },
      { name: "Amber", color: "#ffbf00" },
      { name: "Sea Green", color: "#2e8b57" },
      { name: "Dark Green", color: "#006400" },
      { name: "Pearl", color: "#eae0c8" },
      { name: "Ivory", color: "#fffff0" },
      { name: "Tangerine", color: "#f28500" },
      { name: "Garnet", color: "#733635" },
      { name: "Cherry Red", color: "#de3163" },
      { name: "Emerald", color: "#50c878" },
      { name: "Brunette", color: "#664238" },
      { name: "Sapphire", color: "#0f52ba" },
      { name: "Lilac", color: "#c8a2c8" },
      { name: "Rosewood", color: "#65000b" },
      { name: "Arctic Blue", color: "#0000ff" },
      { name: "Ash", color: "#808080" },
      { name: "Mocha", color: "#C0A392" },
      { name: "Coffee Brown", color: "#6f4e37" },
      { name: "Jet Black", color: "#0a0a0a" },
      { name: "Pista Green", color: "#00ff00" }
    ];

    // Load external images
    const grass_bg = new Image();
    grass_bg.src = "grass_bg.png";
    const store_icon = new Image();
    store_icon.src = "store_icon.png";
    const store_bg = new Image();
    store_bg.src = "cat_bg.png";
    const snake_menu_bg = new Image();
    snake_menu_bg.src = "snake_menu_bg.png";

    // Direction constants
    const UP = { x: 0, y: -1 };
    const DOWN = { x: 0, y: 1 };
    const LEFT = { x: -1, y: 0 };
    const RIGHT = { x: 1, y: 0 };

    /* ======================
       Class Definitions
       ====================== */
    class Snake {
      constructor() {
        this.body = [{ x: 5, y: 5 }];
        this.direction = RIGHT;
        this.growing = false;
      }
      move() {
        let head = this.body[0];
        let new_head = {
          x: (head.x + this.direction.x + COLS) % COLS,
          y: (head.y + this.direction.y + ROWS) % ROWS
        };
        this.body.unshift(new_head);
        if (this.growing) {
          this.growing = false;
        } else {
          this.body.pop();
        }
      }
      grow() {
        this.growing = true;
      }
    }

    class Food {
      constructor() {
        this.position = this.generateNewPosition();
      }
      generateNewPosition() {
        let available = [];
        for (let x = 0; x < COLS; x++) {
          for (let y = 0; y < ROWS; y++) {
            if (
              !snake.body.some(seg => seg.x === x && seg.y === y) &&
              !obstacles.some(obs => obs.x === x && obs.y === y)
            ) {
              available.push({ x, y });
            }
          }
        }
        return available.length ? available[Math.floor(Math.random() * available.length)] : null;
      }
      respawn() {
        this.position = this.generateNewPosition();
      }
    }

    /* ======================
       Helper Functions
       ====================== */
    function resetGame() {
      snake = new Snake();
      food = new Food();
      score = 0;
      level = 1;
      speed = 150;
      appleCount = 0;
      bonusActive = false;
      obstacles = [{ x: 10, y: 8 }, { x: 15, y: 12 }];
    }

    function addObstacle() {
      if (obstacles.length < 10) {
        let available = [];
        for (let x = 0; x < COLS; x++) {
          for (let y = 0; y < ROWS; y++) {
            if (
              !snake.body.some(seg => seg.x === x && seg.y === y) &&
              !obstacles.some(obs => obs.x === x && obs.y === y) &&
              (food.position.x !== x || food.position.y !== y)
            ) {
              available.push({ x, y });
            }
          }
        }
        if (available.length) {
          let new_obs = available[Math.floor(Math.random() * available.length)];
          obstacles.push(new_obs);
        }
      }
    }

    // Draw a rounded rectangle
    function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
      if (typeof radius === "undefined") { radius = 5; }
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    // Helper: Check if a point is in a rectangle
    function pointInRect(x, y, rect) {
      return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
    }

    /* ======================
       Drawing Functions
       ====================== */
    function drawMenu() {
      ctx.drawImage(snake_menu_bg, 0, 0, WIDTH, HEIGHT);
      ctx.font = "72px sans-serif";
      ctx.fillStyle = "#ffffff";
      let titleText = "SNAKE GAME";
      let titleWidth = ctx.measureText(titleText).width;
      ctx.fillText(titleText, (WIDTH - titleWidth) / 2, HEIGHT / 2 - 100);
      let buttonWidth = 140, buttonHeight = 60;
      let buttonX = (WIDTH - buttonWidth) / 2;
      let buttonY = HEIGHT / 2;
      ctx.fillStyle = "rgb(0,200,0)";
      roundRect(ctx, buttonX, buttonY, buttonWidth, buttonHeight, 10, true, false);
      ctx.font = "36px sans-serif";
      ctx.fillStyle = "#ffffff";
      let playText = "Play";
      let playWidth = ctx.measureText(playText).width;
      ctx.fillText(playText, buttonX + (buttonWidth - playWidth) / 2, buttonY + buttonHeight / 2 + 12);
      let iconX = buttonX + buttonWidth + 10;
      let iconY = buttonY + (buttonHeight - 40) / 2;
      ctx.drawImage(store_icon, iconX, iconY, 40, 40);
      return {
        playButtonRect: { x: buttonX, y: buttonY, width: buttonWidth, height: buttonHeight },
        storeIconRect: { x: iconX, y: iconY, width: 40, height: 40 }
      };
    }

    function drawStore() {
      ctx.drawImage(store_bg, 0, 0, WIDTH, HEIGHT);
      ctx.font = "72px sans-serif";
      ctx.fillStyle = "#ffffff";
      let storeTitle = "Store";
      let titleWidth = ctx.measureText(storeTitle).width;
      ctx.fillText(storeTitle, (WIDTH - titleWidth) / 2, 50);
      let squareSize = 40, spacing = 10, colsGrid = 8;
      let totalWidth = colsGrid * squareSize + (colsGrid - 1) * spacing;
      let startX = (WIDTH - totalWidth) / 2;
      let startY = 100;
      let optionRects = [];
      ctx.font = "16px sans-serif";
      for (let i = 0; i < colorOptions.length; i++) {
        let col = i % colsGrid;
        let row = Math.floor(i / colsGrid);
        let x = startX + col * (squareSize + spacing);
        let y = startY + row * (squareSize + spacing);
        ctx.fillStyle = colorOptions[i].color;
        ctx.fillRect(x, y, squareSize, squareSize);
        ctx.lineWidth = (colorOptions[i].color.toLowerCase() === snake_color.toLowerCase()) ? 3 : 1;
        ctx.strokeStyle = "#000000";
        ctx.strokeRect(x, y, squareSize, squareSize);
        optionRects.push({ rect: { x, y, width: squareSize, height: squareSize }, color: colorOptions[i].color });
      }
      let buttonWidth = 140, buttonHeight = 60;
      let buttonX = (WIDTH - buttonWidth) / 2;
      let buttonY = HEIGHT - 100;
      ctx.fillStyle = "rgb(200,0,0)";
      roundRect(ctx, buttonX, buttonY, buttonWidth, buttonHeight, 10, true, false);
      ctx.font = "36px sans-serif";
      ctx.fillStyle = "#ffffff";
      let backText = "Back";
      let backWidth = ctx.measureText(backText).width;
      ctx.fillText(backText, buttonX + (buttonWidth - backWidth) / 2, buttonY + buttonHeight / 2 + 12);
      return {
        backButtonRect: { x: buttonX, y: buttonY, width: buttonWidth, height: buttonHeight },
        optionRects: optionRects
      };
    }

    function drawGameOver() {
      ctx.fillStyle = "#000000";
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.font = "72px sans-serif";
      ctx.fillStyle = RED;
      let gameOverText = "Game Over!";
      let goWidth = ctx.measureText(gameOverText).width;
      ctx.fillText(gameOverText, (WIDTH - goWidth) / 2, HEIGHT / 2 - 50);
      ctx.font = "36px sans-serif";
      ctx.fillStyle = "#ffffff";
      let scoreText = "Final Score: " + score;
      let scoreWidth = ctx.measureText(scoreText).width;
      ctx.fillText(scoreText, (WIDTH - scoreWidth) / 2, HEIGHT / 2);
      let contText = "Click to return to menu";
      let contWidth = ctx.measureText(contText).width;
      ctx.fillText(contText, (WIDTH - contWidth) / 2, HEIGHT / 2 + 50);
    }

    function drawPlaying() {
      ctx.fillStyle = SCOREBOARD_BG;
      ctx.fillRect(0, 0, WIDTH, 100);
      ctx.drawImage(grass_bg, 0, 100, WIDTH, HEIGHT - 100);
      for (let seg of snake.body) {
        ctx.fillStyle = snake_color;
        ctx.fillRect(seg.x * GRID_SIZE, 100 + seg.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
      }
      if (food.position) {
        ctx.fillStyle = RED;
        ctx.fillRect(food.position.x * GRID_SIZE, 100 + food.position.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
      }
      ctx.fillStyle = GRAY;
      for (let obs of obstacles) {
        ctx.fillRect(obs.x * GRID_SIZE, 100 + obs.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
      }
      ctx.font = "36px sans-serif";
      ctx.fillStyle = BLACK;
      let scoreText = "Score: " + score + "  Level: " + level;
      ctx.fillText(scoreText, 10, 40);
      if (bonusActive) {
        ctx.fillStyle = GOLD;
        let bonusText = "ðŸ”¥ 3Ã— BONUS ACTIVE! ðŸ”¥";
        let bonusWidth = ctx.measureText(bonusText).width;
        ctx.fillText(bonusText, (WIDTH - bonusWidth) / 2, 40);
      }
    }

    function draw() {
      if (gameState === "menu") {
        let rects = drawMenu();
        menuPlayButtonRect = rects.playButtonRect;
        menuStoreIconRect = rects.storeIconRect;
      } else if (gameState === "store") {
        let rects = drawStore();
        storeBackButtonRect = rects.backButtonRect;
        storeOptionRects = rects.optionRects;
      } else if (gameState === "game_over") {
        drawGameOver();
      }
    }

    /* ======================
       Game Loop for Playing State
       ====================== */
    function playingGameLoop() {
      if (gameState !== "playing") return;
      updatePlaying();
      drawPlaying();
      gameLoopTimeout = setTimeout(playingGameLoop, speed);
    }

    function updatePlaying() {
      let head = { ...snake.body[0] };
      head.x = (head.x + snake.direction.x + COLS) % COLS;
      head.y = (head.y + snake.direction.y + ROWS) % ROWS;
      // Check self-collision (ignore head)
      if (snake.body.slice(1).some(seg => seg.x === head.x && seg.y === head.y)) {
        gameState = "game_over";
        return;
      }
      snake.body.unshift(head);
      // Check collision with obstacles
      if (obstacles.some(obs => obs.x === head.x && obs.y === head.y)) {
        if (snake.body.length > 1) {
          snake.body.pop();
        } else {
          gameState = "game_over";
          return;
        }
      }
      // Check food collision
      if (food.position && head.x === food.position.x && head.y === food.position.y) {
        snake.grow();
        appleCount++;
        if (bonusActive) {
          score += 30;
          bonusActive = false;
        } else {
          score += 10;
        }
        addObstacle();
        food.respawn();
        if (appleCount === 3) {
          bonusActive = true;
          appleCount = 0;
        }
        if (score % 50 === 0) {
          level += 1;
          speed = Math.max(50, speed - 10);
        }
      } else {
        snake.body.pop();
      }
      // Check for snake death if no segments remain
      if (snake.body.length === 0) {
        gameState = "game_over";
        return;
      }
    }

    /* ======================
       Mouse Event Handling
       ====================== */
    canvas.addEventListener("click", function (event) {
      let rect = canvas.getBoundingClientRect();
      let x = event.clientX - rect.left;
      let y = event.clientY - rect.top;
      if (gameState === "playing") {
        if (y < 100) return;
        let grid_x = Math.floor(x / GRID_SIZE);
        let grid_y = Math.floor((y - 100) / GRID_SIZE);
        let head = snake.body[0];
        let dx = grid_x - head.x;
        let dy = grid_y - head.y;
        let newDir;
        if (Math.abs(dx) > Math.abs(dy)) {
          newDir = dx > 0 ? RIGHT : LEFT;
        } else {
          newDir = dy > 0 ? DOWN : UP;
        }
        // Prevent reversing direction
        if (!(snake.direction.x + newDir.x === 0 && snake.direction.y + newDir.y === 0)) {
          snake.direction = newDir;
        }
      } else if (gameState === "menu") {
        if (menuPlayButtonRect && pointInRect(x, y, menuPlayButtonRect)) {
          resetGame();
          gameState = "playing";
          playingGameLoop();
        } else if (menuStoreIconRect && pointInRect(x, y, menuStoreIconRect)) {
          gameState = "store";
          draw();
        }
      } else if (gameState === "store") {
        if (storeOptionRects) {
          for (let opt of storeOptionRects) {
            if (pointInRect(x, y, opt.rect)) {
              snake_color = opt.color;
            }
          }
        }
        if (storeBackButtonRect && pointInRect(x, y, storeBackButtonRect)) {
          gameState = "menu";
          draw();
        }
      } else if (gameState === "game_over") {
        // On game over, a click anywhere returns to menu
        gameState = "menu";
        draw();
      }
    });

    // Start by drawing the menu
    draw();
  </script>
</body>
</html>
